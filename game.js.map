{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/components/AABB3.js","src/components/Boid.js","src/components/StackFSM.js","src/components/THREECube.js","src/entities/Box.js","src/entities/Minion.js","src/entities/TileAABB.js","src/game.js","src/global.js","src/states/Adventure.js","src/system/CameraRig.js","src/system/GamepadController.js","src/system/World.js","src/system/XboxGamepad.js","src/system/steering.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","AABB3","entity","settings","this","mh","Base","solid","static","width","height","depth","maxSpeed","mass","invmass","restitution","autoAdd","boundaryBehavior","vgp","Boundary","BOUNDARY_BOUNCE","collisionID","uniqueID","collisionGroup","type","onCollision","Signal","utils","merge","position","THREE","Vector3","velocity","accel","min","Vec","max","half","game","debug","cubeGeo","CubeGeometry","cubeMaterial","MeshBasicMaterial","color","wireframe","shading","FlatShading","_debugMesh","Mesh","_v","setMass","update","kai","expect","accessor","className","priority","prototype","constructor","activate","active","copy","sub","add","world","view","disable","set","remove","newMass","setEntity","reset","divideScalar","multiplyScalar","gravity","jumping","y","friction","elapsed","x","z","dispose","Boid","maxForce","slowingRadius","pathArriveRadius","groupID","flockRadius","maxCohesion","minSeparation","angleJitter","targetDistance","targetRadius","util","overwrite","steeringForce","random","body","_wanderAngle","_currentPathNode","_pathDir","_arrived","post","StackFSM","state","stack","stateChanged","_activeContext","_activeFunction","_prevFunction","pushState","ctx","push","popState","pop","dispatch","name","THREECube","textureUrl","container","size","emissive","_display","MeshPhongMaterial","map","ImageUtils","loadTexture","castShadow","receiveShadow","rotation","setFromVector3","g","Minion","Box3","pos","dynamic","Types","DYNAMIC","gameGroup","Groups","ALLY","runSpeed","jumpSpeed","airFriction","pad","clone","addComponent","Components","VIEW_CUBE","BODY_AABB3","STACK_FSM","onCollide","self","input","onConnect","ctrl","onDown","onBtnPress","onDisconnect","_jumpCount","_curVel","_vec","_up","_originalCamRot","cameraRig","orbitOffset","idle","btnId","btnObj","XBOX","X","tower","playerCommand","Commands","DEFEND_ME","Y","m","A","LB","targetOrbit","PI","RB","other","manifold","STATIC","console","log","normal","Math","round","board","tileHeightStep","rightAxis","cam","zoom","updateProjectionMatrix","leftAxis","applyAxisAngle","removeComponent","steer","path","BOID","onCommand","posx","posy","posz","boid","command","data","seek","pathingHeuristic","origin","next","h","TileAABB","cell","tile","worldPos","engine","Engine","CameraRig","hemiLight","HemisphereLight","setRGB","dirLight","DirectionalLight","vg","Scene","element","document","getElementById","cameraPosition","light","cameraType","orthoZoom","camera","Pads","registerComponents","firstState","start","grid","nextLevel","inputBlocked","FAST","ENEMY","DEFEND_CASTLE","ATTACK","ATTACK_CASTLE","window","create","ready","SqrGrid","load","Box","Board","gen","GeneratedTileManager","makeTiles","group","focusOn","World","b","player","render","pivot","Object3D","lookAt","targetPos","deadzone","halfDeadzone","deadzoneY","target","newAngleOffset","lerp","GamepadController","XboxGamepad","controllers","activeControllers","_controllerStatus","addEventListener","_onConnect","bind","_onDisconnect","navigator","getGamepads","_scan","_addPad","gamepad","index","register","_removePad","unregister","evt","gamepads","setPad","boundingBox","setFromObject","tileGroup","tilesPerWorldCell","cellSize","worldCellSize","PX_TO_GRID","bounded","broadphaseGrid","objects","LinkedList","_listPool","ObjectPool","_tilePool","DualPool","_emptyCell","_tileSize","box","BoxHelper","warn","dir","obj","node","otherObj","boardCell","cZEntityMin","cZEntityMax","cXEntityMin","j","cZ","cX","gridCol","gridCell","busy","first","clear","freeAll","floor","cXEntityMax","get","getCellAt","block","physics","separateAABB3AABB3","resolve","getCell","px","py","has","getCells","w","arr","maxX","maxY","ptg","id","onUp","Vector2","leftTrigger","rightTrigger","axisTolerance","controller","buttons","_numButtons","_prevButtons","ctrlr","btn","leftX","axes","leftY","rightX","rightY","value","pressed","isDown","removeAll","B","LT","RT","SELECT","START","LSTICK","RSTICK","UP","DOWN","LEFT","RIGHT","_sumForce","_desiredVec","_scratchVec","_wanderVec","_seperationForce","_cohereForce","_alignForce","agent","dest","distance","distanceTo","normalize","flee","align","flock","neighboursCount","getLength","cohere","separate","wander","setAngle","followPath","repeat","pursue","targetAgent","evade","pursuingAgent"],"mappings":"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","file":"game.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var AABB3 = function(entity, settings) {\n\tsettings = settings || {};\n\tthis.entity = entity || {};\n\tmh.Base.call(this); // always extend Base\n\n\tthis.solid = true;\n\tthis.static = false; // you can have a dynamic object that is immesurably heavy, but this will speed things up\n\tthis.width = 50;\n\tthis.height = 50;\n\tthis.depth = 50;\n\tthis.maxSpeed = 10;\n\n\tthis.mass = 1; // 0 is immobile\n\tthis.invmass = 0; // never adjust this directly! use setMass() instead\n\tthis.restitution = 0.8; // bounciness, 0 to 1\n\n\tthis.autoAdd = true;\n\tthis.boundaryBehavior = vgp.Boundary.BOUNDARY_BOUNCE;\n\tthis.collisionID = this.uniqueID;\n\tthis.collisionGroup = null;\n\tthis.type = entity.type;\n\n\tthis.onCollision = new vgp.Signal();\n\n\t// attribute override\n\tvgp.utils.merge(this, settings);\n\n\tthis.position = entity && entity.position ? entity.position : new THREE.Vector3();\n\tthis.velocity = entity && entity.velocity ? entity.velocity : new THREE.Vector3();\n\tthis.accel = entity && entity.accel ? entity.accel : new THREE.Vector3();\n\n\tthis.min = new vgp.Vec();\n\tthis.max = new vgp.Vec();\n\tthis.half = new vgp.Vec(this.width/2, this.height/2, this.depth/2);\n\n\t// DEBUG\n\tif (game.debug) {\n\t\tvar cubeGeo = new THREE.CubeGeometry(this.width, this.height, this.depth);\n\t\tvar cubeMaterial = new THREE.MeshBasicMaterial({\n\t\t\tcolor: 0x891567,\n\t\t\twireframe: true,\n\t\t\tshading: THREE.FlatShading\n\t\t});\n\t\tthis._debugMesh = new THREE.Mesh(cubeGeo, cubeMaterial);\n\t}\n\n\tthis._v = new vgp.Vec();\n\n\t// init\n\tthis.setMass(this.mass);\n\tthis.update();\n\n\t// prerequisite components\n\tthis.position = mh.kai.expect(entity, 'position', THREE.Vector3);\n};\n\n// required statics for component system\nAABB3.accessor = 'body'; // property name as it sits on an entity\nAABB3.className = 'BODY_AABB3'; // name of component on the mh.Component object\nAABB3.priority = 100; // general position in the engine's component array; updated in ascending order\n\nAABB3.prototype = {\n\tconstructor: AABB3,\n\n\tactivate: function() {\n\t\tthis.active = true;\n\t\tthis.min.copy(this.position).sub(this.half);\n\t\tthis.max.copy(this.position).add(this.half);\n\n\t\tif (this.autoAdd) {\n\t\t\tgame.world.add(this);\n\t\t}\n\n\t\tif (game.debug) {\n\t\t\tmh.kai.view.add(this._debugMesh);\n\t\t}\n\t},\n\n\tdisable: function() {\n\t\tthis.velocity.set();\n\t\tthis.accel.set();\n\t\tthis.active = false;\n\t\tgame.world.remove(this);\n\n\t\tif (game.debug) {\n\t\t\tmh.kai.view.remove(this._debugMesh);\n\t\t}\n\t},\n\n\tsetMass: function(newMass) {\n\t\tthis.mass = newMass;\n\t\tif (newMass <= 0) {\n\t\t\tthis.invmass = 0;\n\t\t} else {\n\t\t\tthis.invmass = 1 / newMass;\n\t\t}\n\t},\n\n\tsetEntity: function(entity, settings) {\n\t\tthis.position = entity.position ? entity.position : new THREE.Vector3();\n\t\tthis.velocity = entity.velocity ? entity.velocity : new THREE.Vector3();\n\t\tthis.accel = entity.accel ? entity.accel : new THREE.Vector3();\n\n\t\tsettings = settings || {};\n\t\tvgp.utils.merge(this, settings);\n\t},\n\n\treset: function() {\n\t\tthis.setMass(this.mass); // make sure invmass is set\n\t},\n\n\tupdate: function() {\n\t\tif (this.static) return;\n\n\t\tvar world = game.world;\n\t\tvar l = this.accel.length();\n\t\tif (l !== 0 && l > this.maxSpeed) {\n\t\t\tthis.accel.divideScalar(l);\n\t\t\tthis.accel.multiplyScalar(this.maxSpeed);\n\t\t}\n\n\t\tthis.accel.add(world.gravity);\n\t\tif (this.entity.jumping) {\n\t\t\t// let them \"float\" a little so they can jump farther\n\t\t\tthis.accel.y -= world.gravity.y * 0.6;\n\t\t}\n\n\t\tthis.velocity.multiplyScalar(world.friction);\n\t\tthis.velocity.add(this.accel);\n\n\t\tthis._v.copy(this.velocity).multiplyScalar(world.elapsed);\n\t\tthis.position.add(this._v);\n\n\t\tthis.min.copy(this.position).sub(this.half);\n\t\tthis.max.copy(this.position).add(this.half);\n\n\t\tif (this.min.x < world.min.x) {\n\t\t\tthis.position.x = world.min.x + this.half.x;\n\t\t\tthis.velocity.x = -this.velocity.x * this.restitution;\n\t\t}\n\t\telse if (this.max.x > world.max.x) {\n\t\t\tthis.position.x = world.max.x - this.half.x;\n\t\t\tthis.velocity.x = -this.velocity.x * this.restitution;\n\t\t}\n\n\t\tif (this.min.z < world.min.z) {\n\t\t\tthis.position.z = world.min.z + this.half.z;\n\t\t\tthis.velocity.z = -this.velocity.z * this.restitution;\n\t\t}\n\t\telse if (this.max.z > world.max.z) {\n\t\t\tthis.position.z = world.max.z - this.half.z;\n\t\t\tthis.velocity.z = -this.velocity.z * this.restitution;\n\t\t}\n\n\t\tif (game.debug) {\n\t\t\tthis._debugMesh.position.copy(this.position);\n\t\t}\n\t},\n\n\tdispose: function() {\n\t\tthis.onCollision.dispose();\n\t\tthis.onCollision = null;\n\t\tthis.entity = null;\n\t\tthis.position = null;\n\t\tthis.velocity = null;\n\t\tthis.accel = null;\n\t\tthis.min = null;\n\t\tthis.max = null;\n\t}\n};\n\nmodule.exports = AABB3;\n","/*\n\tControls the acceleration of an entity and enables steering behaviors to be used.\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nvar Boid = function(entity, settings) {\n\tsettings = settings || {};\n\tmh.Base.call(this);\n\n\t// these are values that achieve optimal behavioral effects--use as a starting point\n\tthis.maxForce = 10;\n\t// arrive\n\tthis.slowingRadius = 50;\n\tthis.pathArriveRadius = 50;\n\t// flocking--these defaults are for entities with a 50 pixel radius\n\tthis.groupID = 0;\n\tthis.flockRadius = 160; // distance where flocking (alignment) starts to happen\n\tthis.maxCohesion = 140; // radius within which cohesion rule is in effect\n\tthis.minSeparation = 70; // distance at which separation rule goes into effect\n\t// wander\n\tthis.angleJitter = 0.9;\n\tthis.targetDistance = 20;\n\tthis.targetRadius = 20;\n\n\t// attribute override\n\tmh.util.overwrite(this, settings);\n\n\tthis.entity = entity;\n\tthis.steeringForce = new THREE.Vector3(mh.util.random(this.maxForce), mh.util.random(this.maxForce));\n\n\tthis.maxSpeed = this.entity.maxSpeed || this.maxForce;\n\tif (entity.body) {\n\t\tthis.maxSpeed = entity.body.maxSpeed;\n\t}\n\n\t// private properties\n\tthis._wanderAngle = 0;\n\t// this._prevAngle = 0;\n\tthis._currentPathNode = 0;\n\tthis._pathDir = 1;\n\tthis._arrived = false;\n\n\t// prerequisite components\n\tthis.position = mh.kai.expect(entity, 'position', THREE.Vector3);\n\tthis.velocity = mh.kai.expect(entity, 'velocity', THREE.Vector3);\n\n\t// this.groupControl = new mh.Signal();\n};\n\n// required statics for component system\nBoid.accessor = 'boid'; // property name as it sits on an entity\nBoid.className = 'BOID'; // name of component on the component definition object\nBoid.priority = 95; // just before the physics components (at 100) but otherwise dead last\nBoid.post = false; // whether or not this component will have a postUpdate() called on it\n\nBoid.prototype = {\n\tconstructor: Boid,\n\n\tactivate: function() {\n\t\tthis.active = true;\n\t\tthis._currentPathNode = 0;\n\t\tthis._pathDir = 1;\n\t\tthis._arrived = false;\n\t},\n\n\tdisable: function() {\n\t\tthis.active = false;\n\t},\n\n\tupdate: function() {\n\t\t// steeringForce has been modified by Steering so cap it and apply\n\t\t// this.steeringForce.clampLength(-this.maxForce, this.maxForce);\n\n\t\t// let physical mass affect movement\n\t\t// this.steeringForce.multiplyScalar(this.entity.body.invmass);\n\t\t// DebugDraw.vector(Kai.debugCtx, this.steeringForce, this.position);\n\n\t\tthis.velocity.x += this.steeringForce.x;\n\t\tthis.velocity.z += this.steeringForce.z;\n\n\t\t// reset for next time, so steering forces get applied in the updates of other components\n\t\tthis.steeringForce.x = 0;\n\t\tthis.steeringForce.z = 0;\n\t},\n\n\tdispose: function() {\n\t\t// this.groupControl.dispose();\n\t\t// this.groupControl = null;\n\t\tthis.entity = null;\n\t\tthis.steeringForce = null;\n\t\tthis.position = null;\n\t\tthis.velocity = null;\n\t}\n};\n\nmodule.exports = Boid;\n","/*\n\tStack-based Finite State Machine.\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nvar StackFSM = function(entity) {\n\tmh.Base.call(this);\n\n\t// public properties\n\tthis.state = null;\n\tthis.stack = [];\n\tthis.entity = entity;\n\n\tthis.stateChanged = new mh.Signal();\n\n\t// private\n\tthis._activeContext = null;\n\tthis._activeFunction = null;\n\tthis._prevFunction = null;\n};\n\n// required statics for component system\nStackFSM.accessor = 'stack'; // property name as it sits on an entity\nStackFSM.className = 'STACK_FSM'; // name of component on the component definition object\nStackFSM.priority = 5; // general position in the engine's component array; the lower, the earlier it's updated\nStackFSM.post = false; // whether or not this component will have a postUpdate() called on it\n\nStackFSM.prototype = {\n\tconstructor: StackFSM,\n\n\tactivate: function() {\n\t\tthis.active = true;\n\t},\n\n\tdisable: function() {\n\t\tthis.active = false;\n\t\tthis.reset();\n\t},\n\n\treset: function() {\n\t\tthis.stack.length = 0;\n\t\tthis._prevFunction = null;\n\t\tthis._activeFunction = null;\n\t},\n\n\tpushState: function(state, ctx) {\n\t\tif (state !== this._activeFunction) {\n\t\t\tthis.stack.push(state);\n\t\t\tthis._activeContext = ctx;\n\n\t\t\tif (!this.active) {\n\t\t\t\tthis.activate();\n\t\t\t}\n\t\t}\n\t},\n\n\tpopState: function() {\n\t\tthis.stack.pop();\n\t\tthis._activeFunction = this.stack.length ? this.stack[this.stack.length - 1] : null;\n\t\tif (!this._activeFunction) {\n\t\t\tthis.stateChanged.dispatch(this.state, 'null');\n\t\t\tthis._prevFunction = null;\n\t\t\tthis.disable();\n\t\t}\n\t},\n\n\tupdate: function() {\n\t\tthis._activeFunction = this.stack.length ? this.stack[this.stack.length - 1] : null;\n\t\tif (this._activeFunction) {\n\t\t\t// monitor changes so entity can react to unique situations\n\t\t\tif (this._activeFunction !== this._prevFunction) {\n\t\t\t\tthis.state = this._activeFunction.name;\n\t\t\t\tthis.stateChanged.dispatch(this._prevFunction ? this._prevFunction.name : 'null', this.state);\n\t\t\t\tthis._prevFunction = this._activeFunction;\n\t\t\t}\n\n\t\t\tthis._activeFunction.call(this._activeContext);\n\t\t}\n\t},\n\n\tdispose: function() {\n\t\tthis.entity = null;\n\t\tthis._activeFunction = null;\n\t\tthis._prevFunction = null;\n\t\tthis.stack = null;\n\t\tthis.stateChanged.dispose();\n\t\tthis.stateChanged = null;\n\t}\n};\n\nmodule.exports = StackFSM;","/*\n\tAbstracts threejs cube creation so it integrates nicely into our entity-component system.\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nvar THREECube = function(entity, settings) {\n\tsettings = settings || {};\n\tmh.Base.call(this);\n\n\t// attributes\n\tthis.textureUrl = null;\n\tthis.container = mh.kai.view;\n\tthis.size = settings.size || [3, 6, 3];\n\t// this.dynamic = false;\n\tthis.color = 0x156289;\n\tthis.emissive = 0x072534;\n\n\tmh.util.overwrite(this, settings);\n\n\t// private properties\n\tthis.entity = entity;\n\tthis._display = null;\n\n\t// NEVER do this in production! geo and materials should be cached!\n\t// But I'm on vacation and this is prototype code so, meh\n\tvar cubeGeo = new THREE.CubeGeometry(this.size[0], this.size[1], this.size[2]);\n\tvar cubeMaterial = new THREE.MeshPhongMaterial({\n\t\tcolor: settings.color || 0x156289,\n\t\tshading: THREE.FlatShading,\n\t\tmap: this.textureUrl ? THREE.ImageUtils.loadTexture(this.textureUrl) : null\n\t});\n\n\tthis._display = new THREE.Mesh(cubeGeo, cubeMaterial);\n\tthis._display.castShadow = true;\n\tthis._display.receiveShadow = true;\n\n\t/*if (!this.dynamic) {\n\t\tthis._display.matrixAutoUpdate = false;\n\t\tthis._display.position.copy(entity.position);\n\t\tthis._display.updateMatrix();\n\t}*/\n\n\t// prerequisite components\n\tthis.position = mh.kai.expect(entity, 'position', THREE.Vector3);\n\tthis.rotation = mh.kai.expect(entity, 'rotation', THREE.Vector3);\n};\n\n// required statics for component system\nTHREECube.accessor = 'view'; // property name as it sits on an entity\nTHREECube.className = 'VIEW_CUBE'; // name of component on the mh.Component object\nTHREECube.priority = 10; // general position in the engine's component array; highest updated first\n\nTHREECube.prototype = {\n\tconstructor: THREECube,\n\n\tactivate: function() {\n\t\tthis.active = true;\n\t\tthis.container.add(this._display);\n\t},\n\n\tdisable: function() {\n\t\tthis.active = false;\n\t\tthis.container.remove(this._display);\n\t},\n\n\tupdate: function() {\n\t\tthis._display.position.copy(this.position);\n\t\tthis._display.rotation.setFromVector3(this.rotation);\n\t},\n\n\tdispose: function() {\n\t\tthis.disable();\n\n\t\t// null references\n\t\tthis.entity = null;\n\t\tthis.position = null;\n\t\tthis._display = null; // if you don't dispose() THREE Geometry, you'll get memory leaks FYI\n\t}\n};\n\nmodule.exports = THREECube;\n","var g = require('../global');\nvar Minion = require('./Minion');\n\n// constructor\nvar Box3 = function(pos, settings) {\n\tsettings = settings || {};\n\tmh.Base.call(this);\n\n\t// attributes\n\tthis.size = [3, 6, 3];\n\tthis.dynamic = true;\n\tthis.type = game.Types.DYNAMIC;\n\tthis.gameGroup = game.Groups.ALLY;\n\tthis.runSpeed = 60;\n\tthis.jumpSpeed = 200;\n\tthis.airFriction = 0.5;\n\tthis.pad = null;\n\n\t/*var sharedAttr = {\n\t\tsize: this.size,\n\t\tdynamic: this.dynamic\n\t};\n\n\tmh.util.merge(sharedAttr, settings);*/\n\n\tthis.position = pos.clone();\n\tthis.velocity = new THREE.Vector3();\n\n\tmh.kai.addComponent(this, g.Components.VIEW_CUBE, {\n\t\tsize: this.size\n\t});\n\tmh.kai.addComponent(this, g.Components.BODY_AABB3, {\n\t\twidth: this.size[0],\n\t\theight: this.size[1],\n\t\tdepth: this.size[2],\n\t\tmaxSpeed: 20,\n\t\tmass: 20\n\t});\n\tmh.kai.addComponent(this, g.Components.STACK_FSM);\n\n\tthis.body.onCollision.add(this.onCollide, this);\n\n\tvar self = this;\n\t// TODO: notify user if pad is there or not\n\tgame.input.onConnect.add(function(ctrl) {\n\t\tself.pad = ctrl;\n\t\tctrl.onDown.add(self.onBtnPress, self);\n\t});\n\n\tgame.input.onDisconnect.add(function(ctrl) {\n\t\tself.pad = null;\n\t});\n\n\tthis._jumpCount = 0;\n\tthis._curVel = new THREE.Vector3();\n\tthis._vec = new THREE.Vector3();\n\tthis._up = new THREE.Vector3(0, -1, 0);\n\tthis._originalCamRot = game.cameraRig.orbitOffset;\n};\n\nBox3.prototype = {\n\tconstructor: Box3,\n\n\t/*-------------------------------------------------------------------------------\n\t\t\t\t\t\t\t\t\tPUBLIC\n\t-------------------------------------------------------------------------------*/\n\n\tactivate: function() {\n\t\tthis.view.activate();\n\t\tthis.body.activate();\n\n\t\tthis.stack.pushState(this.idle, this);\n\t},\n\n\tdisable: function() {\n\t\tthis.view.disable();\n\t\tthis.body.disable();\n\t\tthis.stack.reset();\n\t},\n\n\tonBtnPress: function(btnId, btnObj) {\n\t\tswitch (btnId) {\n\t\t\tcase mh.XBOX.X:\n\t\t\t\tmh.tower.playerCommand.dispatch(g.Commands.DEFEND_ME, this.position);\n\t\t\t\tbreak;\n\t\t\tcase mh.XBOX.Y:\n\t\t\t\tvar m = new Minion();\n\t\t\t\t// console.log(this.position)\n\t\t\t\tm.activate(this.position.x+mh.util.random(3), this.position.y, this.position.z+mh.util.random(3));\n\t\t\t\tbreak;\n\t\t\tcase mh.XBOX.A:\n\t\t\t\t// -14.9 is the rate of gravity in this game\n\t\t\t\tif (!this.jumping && this.velocity.y >= -14.9) {\n\t\t\t\t\tthis.jumping = true;\n\t\t\t\t\t// this.position.y += 0.5;\n\t\t\t\t\tthis.velocity.multiplyScalar(1.5);\n\t\t\t\t\tthis.velocity.y += this.jumpSpeed;\n\t\t\t\t\tthis.body.accel.y += this.jumpSpeed;\n\t\t\t\t\tthis._curVel.x = this.velocity.x;\n\t\t\t\t\tthis._curVel.z = this.velocity.z;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase mh.XBOX.LB:\n\t\t\t\tgame.cameraRig.targetOrbit -= mh.util.PI;\n\t\t\t\tbreak;\n\t\t\tcase mh.XBOX.RB:\n\t\t\t\tif (game.debug) {\n\t\t\t\t\tgame.cameraRig.targetOrbit = this._originalCamRot; // TODO: modulus so limit to -360, 360\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgame.cameraRig.targetOrbit += mh.util.PI;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\tonCollide: function(other, manifold) {\n\t\tif (other.type === game.Types.STATIC) {\n\t\t\t// check manifold for a collision underneath us, meaning we just collided with the ground from a jump\n\t\t\tif (this.jumping/* && manifold.normal.y < 0*/) {\n\t\t\t\tthis.jumping = false;\n\t\t\t\tconsole.log(manifold.normal.y)\n\t\t\t\t// if so, do particle effect and make sound\n\t\t\t}\n\t\t\telse if (manifold.normal.x != 0 || manifold.normal.z != 0) {\n\t\t\t\t// if the player runs into a static object (ie a tile), check its height - if it's a step, then...\n\t\t\t\tif (Math.round(other.position.y + other.half.y - this.position.y - this.body.half.y) === -game.board.tileHeightStep) {\n\t\t\t\t\t// ...automatically step up the entity\n\t\t\t\t\tthis.position.y += game.board.tileHeightStep + 0.1; // TODO: WTF it only steps onto tiles coming from a positive direction??\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tidle: function() {\n\t\tif (!this.pad) return;\n\n\t\t// rightStick orbits camera, also track player around\n\t\tgame.cameraRig.update(this.position, game.debug ? this.pad.rightAxis.x * 0.05 : 0);\n\t\tgame.cameraRig.cam.zoom -= this.pad.rightAxis.y * 0.05;\n\t\tgame.cameraRig.cam.updateProjectionMatrix();\n\n\t\t// TODO: fix: up/down/etc get reveresed when camera is at 90 degrees from default angle\n\t\tthis._vec.x = this.pad.leftAxis.x;\n\t\tthis._vec.z = this.pad.leftAxis.y;\n\t\tthis._vec.applyAxisAngle(this._up, game.cameraRig.orbitOffset + 0.785398163397);\n\n\t\tif (this.jumping) {\n\t\t\tthis.velocity.x = this._curVel.x + this._vec.x * (this.runSpeed * this.airFriction);\n\t\t\tthis.velocity.z = this._curVel.z + this._vec.z * (this.runSpeed * this.airFriction);\n\t\t}\n\t\telse {\n\t\t\tthis.velocity.x = this._vec.x * this.runSpeed;\n\t\t\tthis.velocity.z = this._vec.z * this.runSpeed;\n\t\t}\n\n\t\t/*if (this.jumping) {\n\t\t\tthis.velocity.x = this._curVel.x + this.pad.leftAxis.x * (this.runSpeed * this.airFriction);\n\t\t\tthis.velocity.z = this._curVel.z + this.pad.leftAxis.y * (this.runSpeed * this.airFriction);\n\t\t}\n\t\telse {\n\t\t\tthis.velocity.x = this.pad.leftAxis.x * this.runSpeed;\n\t\t\tthis.velocity.z = this.pad.leftAxis.y * this.runSpeed;\n\t\t}*/\n\n\n\t},\n\n\tdispose: function() {\n\t\t// dispose components\n\t\tmh.kai.removeComponent(this, g.Components.VIEW_CUBE);\n\t\tmh.kai.removeComponent(this, g.Components.BODY_AABB3);\n\t\tmh.kai.removeComponent(this, g.Components.STACK_FSM);\n\n\t\t// null references\n\t\tthis.position = null;\n\t\tthis.velocity = null;\n\t}\n\n};\n\nmodule.exports = Box3;\n","var g = require('../global');\nvar steer = require('../system/steering');\n\nvar Minion = function() {\n\tmh.Base.call(this);\n\n\t// attributes\n\tthis.size = [2, 3, 2];\n\tthis.dynamic = true;\n\tthis.type = game.Types.DYNAMIC;\n\tthis.gameGroup = game.Groups.ALLY;\n\tthis.maxSpeed = 60;\n\tthis.jumpSpeed = 300;\n\tthis.airFriction = 0.5;\n\n\tthis.path = null;\n\n\t// base components\n\tthis.position = new THREE.Vector3();\n\tthis.velocity = new THREE.Vector3();\n\n\t// complex components\n\tmh.kai.addComponent(this, g.Components.VIEW_CUBE, {\n\t\tsize: this.size,\n\t\tcolor: 0x14c21c\n\t});\n\tmh.kai.addComponent(this, g.Components.BODY_AABB3, {\n\t\twidth: this.size[0],\n\t\theight: this.size[1],\n\t\tdepth: this.size[2],\n\t\tmaxSpeed: 40,\n\t\tmass: 1\n\t});\n\tmh.kai.addComponent(this, g.Components.BOID, {\n\n\t});\n\tmh.kai.addComponent(this, g.Components.STACK_FSM);\n\n\tmh.tower.playerCommand.add(this.onCommand, this);\n};\n\nMinion.prototype = {\n\tconstructor: Minion,\n\n\tactivate: function(posx, posy, posz) {\n\t\tthis.active = true;\n\t\tthis.position.set(posx, posy, posz);\n\n\t\tthis.view.activate();\n\t\tthis.body.activate();\n\t\tthis.boid.activate();\n\n\t\tthis.stack.pushState(this.idle, this);\n\t},\n\n\tdisable: function() {\n\t\tthis.active = false;\n\t\tthis.view.disable();\n\t\tthis.body.disable();\n\t\tthis.boid.disable();\n\t\tthis.stack.reset();\n\t},\n\n\tdispose: function() {\n\t\t// dispose components\n\t\tmh.kai.removeComponent(this, g.Components.VIEW_CUBE);\n\t\tmh.kai.removeComponent(this, g.Components.BODY_AABB3);\n\t\tmh.kai.removeComponent(this, g.Components.STACK_FSM);\n\n\t\t// null references\n\t\tthis.position = null;\n\t\tthis.velocity = null;\n\t},\n\n\tonCollide: function(other, manifold) {\n\n\t},\n\n\tonCommand: function(command, data) {\n\t\t// console.log('[Minion] received command:', command);\n\t\tswitch (command) {\n\t\t\tcase g.Commands.DEFEND_ME:\n\t\t\t\t/*var cellA = game.grid.getCellAt(this.position);\n\t\t\t\tvar cellB = game.grid.getCellAt(data);\n\t\t\t\tvar path = game.board.finder.findPath(cellA, cellB, this.pathingHeuristic, game.grid);\n\t\t\t\tfor (var i = 0; i < path.length; i++) {\n\t\t\t\t\tpath[i] = path[i].tile.position;\n\t\t\t\t}\n\t\t\t\tthis.path = path;\n\t\t\t\tthis.boid._currentPathNode = 0;*/\n\t\t\t\tthis.path = data;\n\t\t\t\t// console.log(path)\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\tidle: function() {\n\t\tif (this.path) {\n\t\t\t// steer.followPath(this.boid, this.path, false);\n\t\t\tsteer.seek(this.boid, this.path);\n\t\t}\n\t},\n\n\tpathingHeuristic: function(origin, next) {\n\t\t// example of how to filter out neighbors that are too tall to traverse\n\t\t// but allows the algorithm to \"jump\" down to whatever depth\n\t\tif (next.h - origin.h > 10) {\n\t\t\treturn false; // no, filter out next\n\t\t}\n\t\treturn true; // yes, keep next for consideration\n\t}\n\n};\n\nmodule.exports = Minion;\n","/*\n\tUsed solely by World.js to provide collision boxes for tiles.\n*/\nvar TileAABB = function() {\n\tmh.Base.call(this); // always extend Base\n\n\tthis.solid = true;\n\tthis.static = true;\n\tthis.width = 10;\n\tthis.height = 50;\n\tthis.depth = 10;\n\tthis.maxSpeed = 0;\n\n\tthis.mass = 0; // 0 is immobile\n\tthis.invmass = 0; // never adjust this directly! use setMass() instead\n\tthis.restitution = 0.6; // bounciness, 0 to 1\n\n\tthis.collisionID = 1;\n\tthis.collisionGroup = null;\n\tthis.type = game.Types.STATIC;\n\n\t// this.onCollision = new vgp.Signal();\n\n\tthis.position = new THREE.Vector3();\n\tthis.velocity = new vgp.Vec(); // never changes obvi\n\n\tthis.min = new vgp.Vec();\n\tthis.max = new vgp.Vec();\n\tthis.half = new vgp.Vec(this.width/2, this.height/2, this.depth/2);\n\n\t// DEBUG\n\tif (game.debug) {\n\t\tvar cubeGeo = new THREE.CubeGeometry(this.width, this.height, this.depth);\n\t\tvar cubeMaterial = new THREE.MeshBasicMaterial({\n\t\t\tcolor: 0x08e26c,\n\t\t\twireframe: true,\n\t\t\tshading: THREE.FlatShading\n\t\t});\n\t\tthis._debugMesh = new THREE.Mesh(cubeGeo, cubeMaterial);\n\t\tthis.position = this._debugMesh.position;\n\t}\n};\n\nTileAABB.prototype = {\n\tconstructor: TileAABB,\n\n\tactivate: function(cell) {\n\t\t// console.log(cell)\n\t\tvar tile = cell.tile;\n\t\tvar worldPos = tile.position;\n\t\tthis.position.x = worldPos.x + this.half.x;\n\t\tthis.position.y = worldPos.y - this.half.y;\n\t\tthis.position.z = worldPos.z + this.half.z;\n\n\t\tthis.min.copy(this.position).sub(this.half);\n\t\tthis.max.copy(this.position).add(this.half);\n\n\t\tif (this.active) return; // was already active from before (this object is only used by World)\n\t\t// console.log(this.collisionID)\n\t\tthis.active = true;\n\t\t// game.world.add(this); // tileAABBs are automatically added to grid cells directly\n\t\tif (game.debug) {\n\t\t\tmh.kai.view.add(this._debugMesh);\n\t\t}\n\t},\n\n\tdisable: function() {\n\t\tthis.active = false;\n\t\t// game.world.remove(this);\n\t\tif (game.debug) {\n\t\t\tmh.kai.view.remove(this._debugMesh);\n\t\t}\n\t},\n\n\tdispose: function() {\n\t\t// this.onCollision.dispose();\n\t\t// this.onCollision = null;\n\t\tthis.position = null;\n\t\tthis.velocity = null;\n\t\tthis.min = null;\n\t\tthis.max = null;\n\t\tthis.half = null;\n\t}\n};\n\nmodule.exports = TileAABB;\n","var engine = new mh.Engine();\nvar g = require('./global');\nvar CameraRig = require('./system/CameraRig');\n\ng.debug = true;\n\nvar hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1);\n// hemiLight.color.setHSL(0.9, 1, 0.9);\nhemiLight.color.setRGB(0.549, 0.78, 1);\n// hemiLight.groundColor.setHSL(0.095, 1, 0.75); // brown\n// hemiLight.groundColor.setRGB(0.549, 0.78, 1); // blue\n// hemiLight.groundColor.setRGB(1, 0.949, 0.549); // yellow\nhemiLight.position.set(0, 500, 0);\n\nvar dirLight = new THREE.DirectionalLight(0xffffff, 3);\n// dirLight.color.setHSL( 0.1, 1, 0.95 );\ndirLight.position.set(10, 10, 1);\n\nmh.kai.view = new vg.Scene({\n\telement: document.getElementById('stage'),\n\tcameraPosition: {x:-100, y:100, z:100},\n\tlight: dirLight,\n\tcameraType: 'OrthographicCamera',\n\torthoZoom: 10\n}, false);\n\nmh.kai.view.container.add(hemiLight);\n// mh.kai.view.enableShadows();\n\ng.cameraRig = new CameraRig(mh.kai.view.camera);\n\nvar Pads = require('./system/GamepadController');\ng.input = new Pads();\n\ng.Components = mh.kai.registerComponents([\n\trequire('./components/THREECube'),\n\trequire('./components/StackFSM'),\n\trequire('./components/Boid'),\n\trequire('./components/AABB3')\n]);\n\nvar firstState = 'Adventure';\nengine.state.add(firstState, require('./states/Adventure'));\nengine.start(firstState);\n","var g = {\n\tboard: null,\n\tgrid: null,\n\tworld: null,\n\tnextLevel: 0,\n\n\tinputBlocked: false,\n\tinput: null,\n\n\tcameraRig: null,\n\n\tComponents: null,\n\tTypes: {\n\t\tSTATIC: 'static', // all static environment objects like tiles, trees, buildings\n\t\tDYNAMIC: 'dynamic', // regular entities\n\t\tFAST: 'fast' // projectiles and weapons\n\t},\n\tGroups: {\n\t\tENEMY: 'enemy',\n\t\tALLY: 'ally'\n\t},\n\tCommands: {\n\t\tDEFEND_ME: 'defend me',\n\t\tDEFEND_CASTLE: 'defend our castle',\n\t\tATTACK: 'attack',\n\t\tATTACK_CASTLE: 'attack enemy castle'\n\t}\n};\n\nmodule.exports = g;\nwindow.game = g; // you should NEVER put anything in the global scope but then again you shouldn't make web games either\n","module.exports = {\n\tcreate: function() {\n\t\tthis.ready = false;\n\t\tthis.grid = new vg.SqrGrid();\n\t\tthis.grid.load('./assets/maps/test1.json', this.start, this)\n\t\tgame.grid = this.grid;\n\t\t// console.log(game.world)\n\n\t\tmh.tower.playerCommand = new mh.Signal();\n\t},\n\n\tstart: function() {\n\t\tvar Box = require('../entities/Box');\n\n\t\tvar board = new vg.Board(this.grid);\n\t\tgame.board = board;\n\n\t\tvar gen = new vg.GeneratedTileManager(board);\n\t\tgen.makeTiles();\n\n\t\tmh.kai.view.add(board.group);\n\t\tmh.kai.view.focusOn(board.group);\n\n\t\tvar World = require('../system/World');\n\t\tgame.world = new World();\n\n\t\tvar b = new Box(new THREE.Vector3(-15, 10, -5));\n\t\tb.activate();\n\t\tthis.player = b;\n\n\t\tthis.ready = true;\n\t},\n\n\tupdate: function() {\n\t\tif (!this.ready) return;\n\n\t\tgame.input.update();\n\t\tgame.world.update();\n\t\tmh.kai.view.render();\n\t},\n\n\tdispose: function() {\n\t\t// game.board.dispose();\n\t\tgame.input.dispose();\n\t\tgame.grid.dispose();\n\t\tgame.world.dispose();\n\n\t\tmh.tower.playerCommand.dispose();\n\t}\n};\n","var CameraRig = function(cam) {\n\tthis.pivot = new THREE.Object3D();\n\tthis.cam = cam;\n\n\tthis.pivot.add(this.cam);\n\tmh.kai.view.add(this.pivot);\n\n\tthis.pos = this.pivot.position;\n\tthis.cam.lookAt(this.pos);\n\n\tthis.orbitOffset = 0//3.92699; // 360 - 90 - 45 degrees in radians\n\tthis.targetOrbit = this.orbitOffset;\n\tthis._vec = new THREE.Vector3();\n\tthis.targetPos = new THREE.Vector3();\n\n\tthis.deadzone = 10;\n\tthis.halfDeadzone = this.deadzone / 2;\n\tthis.deadzoneY = 2;\n};\n\nCameraRig.prototype = {\n\tconstructor: CameraRig,\n\n\tupdate: function(target, newAngleOffset) {\n\t\t/*\n\t\t\tthe targetPos is a point inside a \"box\" as defined by deadzone, where the deadzone surrounds the target (the player),\n\t\t\tso when the target tries to go outside the box, that's when the targetPos will keep up. then using lerp it smoothly follows\n\t\t\ttargetPos, creating a very simply free-roaming area for the target point that doesn't jar the player if they move around\n\t\t\ttoo fast. hopefully that makes sense but i'm writing all this code n comments drunk rn, sorry\n\t\t*/\n\t\tif (this.targetPos.x < target.x - this.deadzone) {\n\t\t\tthis.targetPos.x = target.x - this.deadzone;\n\t\t}\n\t\telse if (this.targetPos.x > target.x + this.halfDeadzone) {\n\t\t\tthis.targetPos.x = target.x + this.halfDeadzone;\n\t\t}\n\n\t\tif (this.targetPos.y < target.y - this.deadzoneY) {\n\t\t\tthis.targetPos.y = target.y - this.deadzoneY;\n\t\t}\n\t\telse if (this.targetPos.y > target.y + this.deadzoneY) {\n\t\t\tthis.targetPos.y = target.y + this.deadzoneY;\n\t\t}\n\n\t\tif (this.targetPos.z < target.z - this.halfDeadzone) {\n\t\t\tthis.targetPos.z = target.z - this.halfDeadzone;\n\t\t}\n\t\telse if (this.targetPos.z > target.z + this.deadzone) {\n\t\t\tthis.targetPos.z = target.z + this.deadzone;\n\t\t}\n\n\t\tthis.pos.lerp(this.targetPos, 0.1);\n\n\t\t// rotate the camera smoothly\n\t\tthis.targetOrbit += newAngleOffset;\n\t\tthis.orbitOffset += (this.targetOrbit - this.orbitOffset) * 0.1;\n\t\tthis.pivot.rotation.y = this.orbitOffset;\n\t}\n};\n\nmodule.exports = CameraRig;\n","\n/*\n\tHandles lifecycle of gamepads.\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nvar GamepadController = function() {\n\tvar XboxGamepad = require('../system/XboxGamepad');\n\n\tthis.controllers = [];\n\tthis.onConnect = new mh.Signal();\n\tthis.onDisconnect = new mh.Signal();\n\tthis.activeControllers = 0;\n\n\t// private\n\tthis._controllerStatus = [];\n\n\tfor (var i = 0; i < 4; i++) {\n\t\tthis.controllers[i] = new XboxGamepad(i);\n\t\tthis._controllerStatus[i] = false;\n\t}\n\n\twindow.addEventListener('gamepadconnected', this._onConnect.bind(this), false);\n\twindow.addEventListener('gamepaddisconnected', this._onDisconnect.bind(this), false);\n};\n\nGamepadController.prototype = {\n\tconstructor: GamepadController,\n\n\tupdate: function() {\n\t\tvar i, ctrl;\n\t\tif (navigator.getGamepads) {\n\t\t\tthis._scan(); // very poorly designed, Mozilla... use events, not polling for this!\n\t\t}\n\t\t// don't need to update for this game since the gamepads are components that get updated automatically by motorhaus\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tctrl = this.controllers[i];\n\t\t\tif (ctrl.active) {\n\t\t\t\tctrl.update();\n\t\t\t}\n\t\t}\n\t},\n\n\tdispose: function() {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tthis.controllers[i].dispose();\n\t\t}\n\t\t// null references\n\t\tthis.controllers = null;\n\t\tthis.onConnect.dispose();\n\t\tthis.onDisconnect.dispose();\n\t\tthis.onConnect = null;\n\t\tthis.onDisconnect = null;\n\t\tthis._controllerStatus = null;\n\t},\n\n\t_addPad: function(gamepad) {\n\t\tvar ctrl = this.controllers[gamepad.index];\n\t\tctrl.register(gamepad);\n\n\t\tthis.onConnect.dispatch(ctrl);\n\t\tthis.activeControllers++;\n\t\t// console.log('addPad');\n\t},\n\n\t_removePad: function(gamepad) {\n\t\tvar ctrl = gamepad.index ? this.controllers[gamepad.index] : this.controllers[gamepad];\n\t\tctrl.unregister();\n\n\t\tthis.onDisconnect.dispatch(ctrl);\n\t\tthis.activeControllers--;\n\t\t// console.log('removePad');\n\t},\n\n\t_onConnect: function(evt) {\n\t\tthis._addPad(evt.gamepad);\n\t},\n\n\t_onDisconnect: function(evt) {\n\t\tthis._removePad(evt.gamepad);\n\t},\n\n\t_scan: function() {\n\t\tvar i, gamepads = navigator.getGamepads();\n\t\tfor (i = 0; i < gamepads.length; i++) {\n\t\t\tif (gamepads[i]) {\n\t\t\t\tif (this._controllerStatus[i]) {\n\t\t\t\t\t// this is fucking pathetic, we should be getting live references!\n\t\t\t\t\tthis.controllers[i].setPad(gamepads[i]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._addPad(gamepads[i]);\n\t\t\t\t\tthis._controllerStatus[i] = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse if (!gamepads[i] && this._controllerStatus[i]) {\n\t\t\t\tthis._removePad(i);\n\t\t\t\tthis._controllerStatus[i] = false;\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = GamepadController;\n","/*\n\tyou'll often see a \"world\" object in games that hold entities, and it's purpose is to provide data about\n\tthe world and make entities aware of one another within it, efficiently.\n\tthis one uses a static grid for spatial hashing in a very memory-efficient manner by pooling grid \"cells\"\n\t(just doubly-linked lists) so if no object occupies a cell, it will be freed and used elsewhere.\n\tdue to this feature, an adjacent possibility opens up: it can extend to infinity at virtually no cost. it\n\twill grow as needed and reuse what isn't.\n\tif your game only has a couple dozen colliding entities, it would be more efficient to use the brute-force\n\tmethod, as there is some overhead to maintaining these lists per frame.\n\tquerying is the second-best aspect of grids--if you have a trigger or dynamic object (like a bullet) that\n\tdoesn't react physically, then it can simply go through the cells it occupies looking for something it wants.\n */\nvar World = function() {\n\tvar TileAABB = require('../entities/TileAABB');\n\tvar g = game.grid;\n\tvar b = game.board;\n\n\tthis.boundingBox = new THREE.Box3().setFromObject(b.tileGroup);\n\t// this.cellOffsetX = -this.boundingBox.min.x;\n\t// this.cellOffsetZ = -this.boundingBox.min.z;\n\n\tthis.tilesPerWorldCell = 3; // how many tiles fit in a world/broadphase cell\n\t// World.TILES_TO_WORLDCELL = 1 / this.tilesPerWorldCell; // convert for faster computation\n\n\tvar cellSize = g.cellSize * this.tilesPerWorldCell; // how big the collision grid cells are\n\tvar worldCellsInitCacheSize = 2;\n\n\tthis.worldCellSize = cellSize;\n\tWorld.PX_TO_GRID = 1 / cellSize;\n\n\tthis.active = true;\n\n\tthis.bounded = true;\n\t// universal properties all entities abide by (applied in physics component)\n\tthis.friction = 0.8;\n\tthis.gravity = new THREE.Vector3(0, -1, 0); // -2\n\t// elapsed will probably sit elsewhere in your game, just find-replace with your own\n\tthis.elapsed = 0.0166;\n\t/*\n\t\tsparse array of LinkedLists. and even if a cell is there, doesn't mean it's active!\n\t\talways use this.getCell() to ensure you get a legit cell to use for querying\n\t */\n\tthis.broadphaseGrid = [];\n\t/*\n\t\tworld bounds. subtracts min from entity position to shift grid to avoid negative numbers,\n\t\tso we never try to reach outside this.broadphaseGrid array.\n\t */\n\tthis.min = this.boundingBox.min;\n\tthis.max = this.boundingBox.max;\n\n\tthis.objects = new vgp.LinkedList(); // collision objects occupying the world/broadphase cells\n\n\tthis._listPool = new vgp.ObjectPool(vgp.LinkedList, null, 20); //worldCellsInitCacheSize\n\tthis._tilePool = new mh.DualPool(TileAABB, null, this.tilesPerWorldCell * this.tilesPerWorldCell * 2); //worldCellsInitCacheSize\n\tthis._emptyCell = new vgp.LinkedList(); // faster return for empty queries\n\n\tthis._tileSize = g.cellSize;\n\tthis._vec = new THREE.Vector3();\n\n\tif (game.debug) {\n\t\t// debug stuff, comment out before release\n\t\t/*// this._scratchVec = new vgp.Vec();\n\t\tvar cubeGeo = new THREE.CubeGeometry(this.max.x, this.max.y, this.max.z);\n\t\tvar cubeMaterial = new THREE.MeshBasicMaterial({\n\t\t\tcolor: 0x08e26c,\n\t\t\twireframe: true,\n\t\t\tshading: THREE.FlatShading\n\t\t});\n\t\tthis._debugMesh = new THREE.Mesh(cubeGeo, cubeMaterial);\n\t\tthis.position = this._debugMesh.position;\n\t\tmh.kai.view.add(this._debugMesh);*/\n\n\t\tvar box = new THREE.BoxHelper(b.tileGroup, 0xffff00);\n\t\tmh.kai.view.add(box);\n\t}\n};\n\nWorld.PX_TO_GRID = 0;\n// World.TILES_TO_WORLDCELL = 0;\n\nWorld.prototype = {\n\tconstructor: World,\n\n\t// _sortedLayer: null,\n\n\t/*-------------------------------------------------------------------------------\n\t\t\t\t\t\t\t\t\tPUBLIC\n\t-------------------------------------------------------------------------------*/\n\n\t/*countGroup: function(groupType) {\n\t\tvar obj, node = this.objects.first;\n\t\tvar total = 0;\n\t\twhile (node) {\n\t\t\tobj = node.obj;\n\t\t\tif (obj.active && obj.collisionGroup === groupType) {\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn total;\n\t},*/\n\n\t// e must be an entity with a collision body or the body itself, like an AABB\n\tadd: function(e) {\n\t\te = e.body || e;\n\t\tif (!e.collisionID) {\n\t\t\tconsole.warn('[vgp.World.add] Ignoring object; must be an entity or physics component');\n\t\t\tconsole.dir(e);\n\t\t\treturn;\n\t\t}\n\t\tthis.objects.add(e);\n\t},\n\n\tremove: function(e) {\n\t\te = e.body || e;\n\t\t// harmless: if it doesn't exist, will return silently\n\t\tthis.objects.remove(e);\n\t},\n\n\t/*\n\t\tall entities should have been updated before this is called so it has the latest position data.\n\t */\n\tupdate: function() {\n\t\tvar manifold, obj, node, otherObj, other, boardCell;\n\t\tvar cZEntityMin,cZEntityMax,cXEntityMin,cZEntityMax,i,j,cZ,cX,gridCol,gridCell;\n\n\t\t// make all cells and blocks usable again so we start fresh with empty cells - that's how we take care of entities moving out of old cells\n\t\tnode = this._listPool.busy.first;\n\t\twhile (node) {\n\t\t\tobj = node.obj;\n\t\t\tnode = node.next;\n\t\t\tobj.clear(); // clear out any entitise that were in this cell\n\t\t\tobj.active = false; // mark this cell as empty of tiles\n\t\t}\n\n\t\tthis._tilePool.freeAll();\n\t\tthis._vec.y = 0;\n\t\tvar count = 0;\n\n\t\t// add all active objects to appropriate cells and resolve collisions among them\n\t\tnode = this.objects.first;\n\t\twhile (node) {\n\t\t\tobj = node.obj;\n\t\t\tnode = node.next;\n\n\t\t\tif (!obj.solid || !obj.active) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// subtract min to shift grid to avoid negative numbers\n\t\t\tcXEntityMin = Math.floor(obj.min.x * World.PX_TO_GRID);\n\t\t\tcXEntityMax = Math.floor(obj.max.x * World.PX_TO_GRID);\n\t\t\tcZEntityMin = Math.floor(obj.min.z * World.PX_TO_GRID);\n\t\t\tcZEntityMax = Math.floor(obj.max.z * World.PX_TO_GRID);\n\n\t\t\t// insert entity into each cell it overlaps\n\t\t\t// we're looping to make sure that all cells between min/max are found (in case the entity is on the border between cells, or larger than an entire cell)\n\t\t\tfor (cZ = cZEntityMin; cZ <= cZEntityMax; cZ++) {\n\t\t\t\t// these only get created once per world init on an as-needed basis (allows for worlds of infinite size without eating All The RAM)\n\t\t\t\tgridCol = this.broadphaseGrid[cZ];\n\t\t\t\tif (!gridCol) {\n\t\t\t\t\tgridCol = [];\n\t\t\t\t\tthis.broadphaseGrid[cZ] = gridCol;\n\t\t\t\t}\n\t\t\t\t// loop through each cell in this column\n\t\t\t\tfor (cX = cXEntityMin; cX <= cXEntityMax; cX++) {\n\t\t\t\t\tgridCell = gridCol[cX];\n\t\t\t\t\t// ensure we have a bucket to put entities into for this cell\n\t\t\t\t\tif (!gridCell) {\n\t\t\t\t\t\t// this is also only done once per world init to ensure that only used cells get allocated\n\t\t\t\t\t\tgridCell = this._listPool.get();\n\t\t\t\t\t\tgridCell.active = false; // set it to false so it gets populated with collision blocks\n\t\t\t\t\t\tgridCol[cX] = gridCell;\n\t\t\t\t\t}\n\t\t\t\t\t// if this cell doesn't already have blocks (from a previous entity that's also occupying it this frame) then activate them for this cell\n\t\t\t\t\tif (!gridCell.active) {\n\t\t\t\t\t\t// fill this cell with blocks so entities know where the ground is - this is only done once per frame\n\t\t\t\t\t\t// having this boolean allows us to avoid allocating new arrays every tick\n\t\t\t\t\t\tgridCell.active = true;\n\t\t\t\t\t\ti = cX * this.worldCellSize;\n\t\t\t\t\t\tj = cZ * this.worldCellSize;\n\t\t\t\t\t\t// i'm sure there's something far more efficient, but this is Good Enough - i have the rest of the game to make\n\t\t\t\t\t\tthis._vec.x = i;\n\t\t\t\t\t\tthis._vec.z = j;\n\t\t\t\t\t\tboardCell = game.grid.getCellAt(this._vec);\n\t\t\t\t\t\tif (boardCell) {\n\t\t\t\t\t\t\tblock = this._tilePool.get();\n\t\t\t\t\t\t\tblock.activate(boardCell);\n\t\t\t\t\t\t\tgridCell.add(block);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._vec.x = i + this._tileSize;\n\t\t\t\t\t\tthis._vec.z = j;\n\t\t\t\t\t\tboardCell = game.grid.getCellAt(this._vec);\n\t\t\t\t\t\tif (boardCell) {\n\t\t\t\t\t\t\tblock = this._tilePool.get();\n\t\t\t\t\t\t\tblock.activate(boardCell);\n\t\t\t\t\t\t\tgridCell.add(block);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._vec.x = i + this._tileSize + this._tileSize;\n\t\t\t\t\t\tthis._vec.z = j;\n\t\t\t\t\t\tboardCell = game.grid.getCellAt(this._vec);\n\t\t\t\t\t\tif (boardCell) {\n\t\t\t\t\t\t\tblock = this._tilePool.get();\n\t\t\t\t\t\t\tblock.activate(boardCell);\n\t\t\t\t\t\t\tgridCell.add(block);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._vec.x = i;\n\t\t\t\t\t\tthis._vec.z = j + this._tileSize;\n\t\t\t\t\t\tboardCell = game.grid.getCellAt(this._vec);\n\t\t\t\t\t\tif (boardCell) {\n\t\t\t\t\t\t\tblock = this._tilePool.get();\n\t\t\t\t\t\t\tblock.activate(boardCell);\n\t\t\t\t\t\t\tgridCell.add(block);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._vec.x = i + this._tileSize;\n\t\t\t\t\t\tthis._vec.z = j + this._tileSize;\n\t\t\t\t\t\tboardCell = game.grid.getCellAt(this._vec);\n\t\t\t\t\t\tif (boardCell) {\n\t\t\t\t\t\t\tblock = this._tilePool.get();\n\t\t\t\t\t\t\tblock.activate(boardCell);\n\t\t\t\t\t\t\tgridCell.add(block);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._vec.x = i + this._tileSize + this._tileSize;\n\t\t\t\t\t\tthis._vec.z = j + this._tileSize;\n\t\t\t\t\t\tboardCell = game.grid.getCellAt(this._vec);\n\t\t\t\t\t\tif (boardCell) {\n\t\t\t\t\t\t\tblock = this._tilePool.get();\n\t\t\t\t\t\t\tblock.activate(boardCell);\n\t\t\t\t\t\t\tgridCell.add(block);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._vec.x = i;\n\t\t\t\t\t\tthis._vec.z = j + this._tileSize + this._tileSize;\n\t\t\t\t\t\tboardCell = game.grid.getCellAt(this._vec);\n\t\t\t\t\t\tif (boardCell) {\n\t\t\t\t\t\t\tblock = this._tilePool.get();\n\t\t\t\t\t\t\tblock.activate(boardCell);\n\t\t\t\t\t\t\tgridCell.add(block);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._vec.x = i + this._tileSize;\n\t\t\t\t\t\tthis._vec.z = j + this._tileSize + this._tileSize;\n\t\t\t\t\t\tboardCell = game.grid.getCellAt(this._vec);\n\t\t\t\t\t\tif (boardCell) {\n\t\t\t\t\t\t\tblock = this._tilePool.get();\n\t\t\t\t\t\t\tblock.activate(boardCell);\n\t\t\t\t\t\t\tgridCell.add(block);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._vec.x = i + this._tileSize + this._tileSize;\n\t\t\t\t\t\tthis._vec.z = j + this._tileSize + this._tileSize;\n\t\t\t\t\t\tboardCell = game.grid.getCellAt(this._vec);\n\t\t\t\t\t\tif (boardCell) {\n\t\t\t\t\t\t\tblock = this._tilePool.get();\n\t\t\t\t\t\t\tblock.activate(boardCell);\n\t\t\t\t\t\t\tgridCell.add(block);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// loop again to check collisions with entities already in this cell before adding ourselves\n\t\t\t\t\tother = gridCell.first;\n\t\t\t\t\twhile (other) {\n\t\t\t\t\t\totherObj = other.obj;\n\t\t\t\t\t\tother = other.next;\n\n\t\t\t\t\t\tif (otherObj.collisionID === obj.collisionID) {\n\t\t\t\t\t\t\t// prevents static objects from colliding into other static objects, such as tiles\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tno hash check for duplicates since the collision check would have moved them out of intersection and therefore fail (early, at that) the next time, making it impossible to apply impulses multiple times. anyway, a hash would thrash the gc (since it has to be recreated each frame).\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tmanifold = vgp.physics.separateAABB3AABB3(obj, otherObj);\n\t\t\t\t\t\tif (manifold) {\n\t\t\t\t\t\t\tvgp.physics.resolve(obj, otherObj, manifold);\n\n\t\t\t\t\t\t\tif (obj.onCollision) obj.onCollision.dispatch(otherObj, manifold);\n\t\t\t\t\t\t\tif (otherObj.onCollision) otherObj.onCollision.dispatch(obj, manifold);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgridCell.add(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/*\n\t\tonly to be used for queries, never modify the cells directly!\n\t */\n\tgetCell: function(px, py) {\n\t\tpx = Math.floor(px * World.PX_TO_GRID);\n\t\tpy = Math.floor(py * World.PX_TO_GRID);\n\t\tif (this.broadphaseGrid[px] && this.broadphaseGrid[px][py] && this._listPool.busy.has(this.broadphaseGrid[px][py])) {\n\t\t\t// must exist and be in use, otherwise it could exist but contain old data\n\t\t\treturn this.broadphaseGrid[px][py];\n\t\t}\n\t\treturn this._emptyCell;\n\t},\n\n\t/*\n\t\tget a number of cells and put them in an array that must be provided.\n\t\tagain, never modify the cells, only loop through them for their occupants!\n\t */\n\tgetCells: function(px, py, w, h, arr) {\n\t\tvar cZ, cX, maxX, maxY, gridCol, gridCell, ptg = World.PX_TO_GRID;\n\t\tpx = Math.floor(px * ptg);\n\t\tpy = Math.floor(py * ptg);\n\t\tmaxX = px + Math.floor(w * ptg);\n\t\tmaxY = py + Math.floor(h * ptg);\n\t\tfor (cZ = px; cZ <= maxX; cZ++) {\n\t\t\t// make sure a column exists, initialize if not to grid height length\n\t\t\tif (!this.broadphaseGrid[cZ]) {\n\t\t\t\t// if the column doesn't exist, there's nothing in it, so move on\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgridCol = this.broadphaseGrid[cZ];\n\n\t\t\t// loop through each cell in this column\n\t\t\tfor (cX = py; cX <= maxY; cX++) {\n\t\t\t\tif (!gridCol[cX]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgridCell = this.broadphaseGrid[cZ][cX];\n\t\t\t\t// finally, make sure this isn't a ghost reference by checking if it's in use\n\t\t\t\tif (this._listPool.busy.has(gridCell)) {\n\t\t\t\t\tarr.push(gridCell);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t},\n\n\tdisable: function() {\n\t\tthis.active = false;\n\t},\n\n\tdispose: function() {\n\t\tthis.objects.dispose();\n\t\tthis.objects = null;\n\t\tthis.broadphaseGrid = null;\n\t\tthis.min = null;\n\t\tthis.max = null;\n\t\tthis._emptyCell = null;\n\t}\n};\n\nmodule.exports = World;\n","/*\n\tHandles specifics of Xbox controllers, used in conjunction with GamepadController.\n\tNot a component.\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nvar XboxGamepad = function(id) {\n\tmh.Base.call(this);\n\n\t// attributes\n\tthis.id = id;\n\tthis.onDown = new mh.Signal();\n\tthis.onUp = new mh.Signal();\n\n\t// NOTE: 'up' is y-, 'right' is x+, all values normalized\n\tthis.leftAxis = new THREE.Vector2();\n\tthis.rightAxis = new THREE.Vector2();\n\tthis.leftTrigger = 0;\n\tthis.rightTrigger = 0;\n\n\t// xbox 360 sticks drift a CONSIDERABLE amount\n\tthis.axisTolerance = 0.2;\n\n\tthis.controller = null;\n\tthis.buttons = null;\n\n\tthis._numButtons = 0;\n\tthis._prevButtons = [];\n};\n\nXboxGamepad.prototype = {\n\tconstructor: XboxGamepad,\n\n\tregister: function(ctrlr) {\n\t\tthis.setPad(ctrlr);\n\t\tthis._numButtons = this.buttons.length;\n\n\t\t/*for (i = 0; i < this._numButtons; i++) {\n\t\t\tthis._prevButtons[i] = this.buttons[i];\n\t\t}*/\n\n\t\tthis.activate();\n\t\tconsole.log('[XboxGamepad.register] CONNECTED '+this.id);\n\t\t// console.log(this.buttons);\n\t},\n\n\tunregister: function() {\n\t\tthis.disable();\n\t\tthis.controller = null;\n\t\tthis.buttons = null;\n\t\tthis._numButtons = 0;\n\t\tconsole.log('[XboxGamepad.unregister] DISCONNECTED '+this.id);\n\t},\n\n\tsetPad: function(ctrlr) {\n\t\tthis.controller = ctrlr;\n\t\tthis.buttons = ctrlr.buttons;\n\t},\n\n\tupdate: function() {\n\t\tvar i, btn;\n\t\tvar leftX = this.controller.axes[0];\n\t\tvar leftY = this.controller.axes[1];\n\t\tvar rightX = this.controller.axes[2];\n\t\tvar rightY = this.controller.axes[3];\n\n\t\tif (leftX < this.axisTolerance && leftX > -this.axisTolerance) { leftX = 0; }\n\t\tif (leftY < this.axisTolerance && leftY > -this.axisTolerance) { leftY = 0; }\n\t\tif (rightX < this.axisTolerance && rightX > -this.axisTolerance) { rightX = 0; }\n\t\tif (rightY < this.axisTolerance && rightY > -this.axisTolerance) { rightY = 0; }\n\n\t\tthis.leftAxis.x = leftX;\n\t\tthis.leftAxis.y = leftY;\n\t\tthis.rightAxis.x = rightX;\n\t\tthis.rightAxis.y = rightY;\n\n\t\tfor (i = 0; i < this._numButtons; i++) {\n\t\t\tbtn = this.buttons[i];\n\n\t\t\tif (i === 6) {\n\t\t\t\tthis.leftTrigger = btn.value || btn;\n\t\t\t}\n\t\t\telse if (i === 7) {\n\t\t\t\tthis.rightTrigger = btn.value || btn;\n\t\t\t}\n\n\t\t\tif (btn.pressed && !this._prevButtons[i]) {\n\t\t\t\tthis.onDown.dispatch(i, btn);\n\n\t\t\t}\n\t\t\telse if (!btn.pressed && this._prevButtons[i]) {\n\t\t\t\tthis.onUp.dispatch(i, btn);\n\t\t\t}\n\n\t\t\tthis._prevButtons[i] = btn.pressed;\n\t\t}\n\t},\n\n\tisDown: function(btn) {\n\t\tif (mh.kai.inputBlocked || !this.active) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !!this.buttons[btn];\n\t},\n\n\tactivate: function() {\n\t\tthis.active = true;\n\t\tthis.leftAxis.x = 0;\n\t\tthis.leftAxis.y = 0;\n\t\tthis.rightAxis.x = 0;\n\t\tthis.rightAxis.y = 0;\n\t\tthis.leftTrigger = 0;\n\t\tthis.rightTrigger = 0;\n\t\tfor (var i = 0; i < this._numButtons; i++) {\n\t\t\tthis.buttons[i] = 0;\n\t\t\tthis._prevButtons[i] = 0;\n\t\t}\n\t},\n\n\tdisable: function() {\n\t\tthis.active = false;\n\n\t\tthis.onDown.removeAll();\n\t\tthis.onUp.removeAll();\n\t},\n\n\tdispose: function() {\n\t\t// remove signal callbacks\n\t\tthis.onDown.dispose();\n\t\tthis.onUp.dispose();\n\n\t\t// null references\n\t\tthis.onDown = null;\n\t\tthis.onUp = null;\n\t}\n};\n\nmh.XBOX = {\n\tA: 0,\n\tB: 1,\n\tX: 2,\n\tY: 3,\n\tLB: 4,\n\tRB: 5,\n\tLT: 6,\n\tRT: 7,\n\tSELECT: 8,\n\tSTART: 9,\n\tLSTICK: 10,\n\tRSTICK: 11,\n\tUP: 12,\n\tDOWN: 13,\n\tLEFT: 14,\n\tRIGHT: 15\n};\n\nmodule.exports = XboxGamepad;\n","/*\n\t\"Boid\" behavior algorithms for more natural entity movement.\n\t@author Corey Birnbaum http://coldconstructs.com/ @vonWolfehaus\n*/\nmodule.exports = {\n\t// cache of objects for reuse; there are a set for each function so they don't get overwritten\n\t_sumForce: new THREE.Vector3(),\n\t_desiredVec: new THREE.Vector3(),\n\t_scratchVec: new THREE.Vector3(),\n\n\t_wanderVec: new THREE.Vector3(),\n\t_seperationForce: new THREE.Vector3(),\n\t_cohereForce: new THREE.Vector3(),\n\t_alignForce: new THREE.Vector3(),\n\t_wanderAngle: 0,\n\n\tseek: function(agent, dest, slowingRadius) {\n\t\tvar distance = agent.position.distanceTo(dest);\n\t\tslowingRadius = slowingRadius || 0;\n\n\t\tif (distance < 7) {\n\t\t\t// friction should bring the agent to a full stop\n\t\t\tagent.velocity.multiplyScalar(0.9);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._desiredVec.copy(dest).sub(agent.position);\n\t\tthis._desiredVec.normalize();\n\n\t\tif (distance < slowingRadius) {\n\t\t\tthis._desiredVec.multiplyScalar(agent.maxForce * (distance / slowingRadius));\n\t\t\tagent.velocity.multiplyScalar(0.9); // apply friction to fight velocity (ie brake)\n\t\t}\n\t\telse {\n\t\t\tthis._desiredVec.multiplyScalar(agent.maxForce);\n\t\t}\n\n\t\tagent.steeringForce.add(this._desiredVec);\n\t},\n\n\tflee: function(agent, dest) {\n\t\tthis._desiredVec.copy(agent.position).sub(dest);\n\t\tthis._desiredVec.normalize().multiplyScalar(agent.maxForce);\n\n\t\tagent.steeringForce.add(this._desiredVec);\n\t},\n\n\talign: function(agent, flock) {\n\t\tvar a, distance, neighboursCount = 0;\n\t\tvar node = flock.first;\n\t\tthis._alignForce.x = 0;\n\t\tthis._alignForce.z = 0;\n\n\t\t// for each of our neighbors (including self)...\n\t\twhile (node) {\n\t\t\ta = node.obj.entity.boid;\n\t\t\tif (a.groupID !== agent.groupID) {\n\t\t\t\tnode = node.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdistance = agent.position.distanceTo(a.position);\n\t\t\t// ...that are within the max distance and are moving...\n\t\t\tif (distance < agent.maxCohesion && a.velocity.getLength() > 0) {\n\t\t\t\t// ...sum up our headings\n\t\t\t\tthis._scratchVec.copy(a.velocity);\n\t\t\t\tthis._scratchVec.normalize();\n\t\t\t\tthis._alignForce.add(this._scratchVec);\n\t\t\t\t// also check if they're where we want to be and call it good\n\t\t\t\tif (a._arrived) agent._arrived = true;\n\t\t\t\tneighboursCount++;\n\t\t\t}\n\t\t\tnode = node.next;\n\t\t}\n\n\t\tif (neighboursCount === 0) {\n\t\t\treturn this._alignForce; // zero\n\t\t}\n\n\t\t// divide to get the average heading\n\t\tthis._alignForce.divideScalar(neighboursCount);\n\t\tthis._alignForce.multiplyScalar(agent.maxForce);\n\n\t\treturn this._alignForce;\n\t},\n\n\tcohere: function(agent, flock) {\n\t\tvar a, distance,\n\t\t\tneighboursCount = 0,\n\t\t\tnode = flock.first;\n\n\t\tthis._sumForce.x = 0;\n\t\tthis._sumForce.z = 0;\n\n\t\twhile (node) {\n\t\t\ta = node.obj.entity.boid;\n\t\t\tif (a !== agent && a.groupID === agent.groupID) {\n\t\t\t\tdistance = agent.position.distanceTo(a.position);\n\t\t\t\tif (distance < agent.maxCohesion) {\n\t\t\t\t\t// sum up the position of our neighbors\n\t\t\t\t\tthis._sumForce.add(a.position);\n\t\t\t\t\tif (a._arrived) agent._arrived = true;\n\t\t\t\t\tneighboursCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = node.next;\n\t\t}\n\n\t\tif (neighboursCount === 0) {\n\t\t\tthis._cohereForce.x = 0;\n\t\t\tthis._cohereForce.z = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// get the average position of ourself and our neighbors\n\t\tthis._sumForce.divideScalar(neighboursCount);\n\n\t\t// seek that position\n\t\tthis._cohereForce.copy(this._sumForce).sub(agent.position);\n\t\tthis._cohereForce.normalize().multiplyScalar(agent.maxForce);\n\n\t\treturn this._cohereForce;\n\t},\n\n\tseparate: function(agent, flock) {\n\t\tvar neighboursCount = 0;\n\t\tvar node = flock.first;\n\n\t\tthis._seperationForce.x = 0;\n\t\tthis._seperationForce.z = 0;\n\n\t\twhile (node) {\n\t\t\tvar a = node.obj.entity.boid;\n\t\t\tif (a !== agent) {\n\t\t\t\tvar distance = agent.position.distanceTo(a.position);\n\t\t\t\tif (distance < agent.minSeparation && distance > 0) {\n\t\t\t\t\t// vector to other agent\n\t\t\t\t\tthis._scratchVec.copy(a.position).sub(agent.position);\n\t\t\t\t\t// var length = this._scratchVec.normalize();\n\t\t\t\t\tvar length = this._scratchVec.getLength();\n\t\t\t\t\tvar r = agent.minSeparation + a.minSeparation;\n\n\t\t\t\t\tthis._scratchVec.multiplyScalar(1 - ((length - r) / (agent.minSeparation - r)));\n\t\t\t\t\tthis._seperationForce.x += this._scratchVec.x;\n\t\t\t\t\tthis._seperationForce.z += this._scratchVec.z;\n\n\t\t\t\t\tneighboursCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = node.next;\n\t\t}\n\n\t\tif (neighboursCount === 0) {\n\t\t\treturn this._seperationForce;\n\t\t}\n\n\t\tthis._seperationForce.multiplyScalar(agent.maxForce / neighboursCount);\n\n\t\treturn this._seperationForce;\n\t},\n\n\twander: function(agent) {\n\t\tthis._desiredVec.copy(agent.velocity);\n\t\tthis._desiredVec.normalize();\n\t\tthis._desiredVec.multiplyScalar(agent.targetDistance);\n\n\t\tthis._scratchVec.reset(0, -1);\n\t\tthis._scratchVec.multiplyScalar(agent.targetRadius);\n\t\tthis._scratchVec.setAngle(agent._wanderAngle);\n\n\t\tagent._wanderAngle += (Math.random() * agent.angleJitter) - (agent.angleJitter * 0.5);\n\n\t\tthis._desiredVec.add(this._scratchVec);\n\t\tagent.steeringForce.add(this._desiredVec);\n\t},\n\n\n\t/*-------------------------------------------------------------------------------\n\t\t\t\t\t\t\t\t\tCOMPOSITE BEHAVIORS\n\t-------------------------------------------------------------------------------*/\n\n\tflock: function(agent, flock) {\n\t\tthis.separate(agent, flock);\n\t\tthis.align(agent, flock);\n\t\tthis.cohere(agent, flock);\n\t\tthis._seperationForce.multiplyScalar(0.2);\n\t\tthis._alignForce.multiplyScalar(1.3);\n\t\tthis._cohereForce.multiplyScalar(0.6);\n\t\tagent.steeringForce.x += this._seperationForce.x + this._alignForce.x + this._cohereForce.x;\n\t\tagent.steeringForce.z += this._seperationForce.z + this._alignForce.z + this._cohereForce.z;\n\t},\n\n\tfollowPath: function(agent, path, repeat) {\n\t\tvar target = path[agent._currentPathNode];\n\t\tif (!target) {\n\t\t\tagent._arrived = true;\n\t\t\tagent._currentPathNode = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (agent._arrived || agent.position.distanceTo(target) <= agent.pathArriveRadius) {\n\t\t\tagent._currentPathNode += agent._pathDir;\n\t\t\tagent._arrived = false;\n\n\t\t\tif (agent._currentPathNode >= path.length || agent._currentPathNode < 0) {\n\t\t\t\tif (repeat) {\n\t\t\t\t\tagent._pathDir *= -1;\n\t\t\t\t\tagent._currentPathNode += agent._pathDir;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tagent._currentPathNode = path.length - 1;\n\t\t\t\t\ttarget = path[agent._currentPathNode];\n\t\t\t\t\tagent._arrived = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.seek(agent, target, agent.slowingRadius);\n\t},\n\n\tpursue: function(agent, targetAgent) {\n\t\t// calculate future position of target\n\t\tthis._scratchVec.copy(targetAgent.position).add(targetAgent.velocity);\n\t\tthis._scratchVec.multiplyScalar(agent.distanceTo(targetAgent) / agent.maxForce);\n\t\t// and seek that instead\n\t\tthis.seek(agent, this._scratchVec);\n\t},\n\n\tevade: function(agent, pursuingAgent) {\n\t\tthis._scratchVec.copy(pursuingAgent.position).add(pursuingAgent.velocity);\n\t\tthis._scratchVec.multiplyScalar(agent.distanceTo(pursuingAgent) / agent.maxForce);\n\n\t\tthis.flee(agent, this._scratchVec);\n\t},\n\n\t/*followLeader: function(agent, leader, flock) {\n\t\tvar tv :Vector3D = leader.velocity.clone();\n\t\tvar force :Vector3D = new Vector3D();\n\n\t\ttv.normalize();\n\t\ttv.scaleBy(LEADER_BEHIND_DIST);\n\n\t\tahead = leader.position.clone().add(tv);\n\n\t\ttv.scaleBy(-1);\n\t\tbehind = leader.position.clone().add(tv);\n\n\t\tif (isOnLeaderSight(leader, ahead)) {\n\t\t\talpha = 0.4;\n\t\t\tforce = force.add(evade(leader));\n\t\t\tforce.scaleBy(1.8); // make evade force stronger...\n\t\t} else {\n\t\t\talpha = 1;\n\t\t}\n\n\t\tforce = force.add(arrive(behind, 50));\n\t\tforce = force.add(separation(agent, flock));\n\n\t\tagent.steeringForce.add(this._desiredVec);\n\t}*/\n};\n"]}